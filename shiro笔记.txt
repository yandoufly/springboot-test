
主要知识点：(需要掌握!!!)
	1、认证、授权、realm
	2、配置类 shiroFilter securityManager realm
	3、shiro过滤器（在shiroFilter中配置）
		内置过滤器，如anon、logout、user、authc等
		自定义过滤器，如shiroOrFilter
	4、会话管理器 SessionManager SessionDao	redis实现session共享
	5、缓存管理，用于缓存角色和权限数据，redis实现 还可以做一个本地二级缓存，将redis数据存入本地变量中，这样就不用每次都读取redis数据
	6、记住我rememberMe cookieRememberManager类


shiro六大体系结构：
	Authentication		--认证，用户登录
	Authorization		--授权，用户具有哪些权限
	Cryptography		--安全数据加密
	SessionManagement	--会话管理
	Web Integration		--web系统集成
	Interations			--集成其它应用，spring、缓存等

shiro的三个核心类：
1.Subject	--用户主体
	通过SecurityUtils.getSubject()获取。
	主要方法：登录login、注销logout、是否认证isAuthenticated、拥有某角色hasRole、某权限isPermitted。
	如：
		Subject subject = SecurityUtils.getSubject();
		subject.login();

2.SecurityManager --核心类，安全管理器。
	注入Realm、缓存管理器CacheManager（可在realm注入）、会话管理器SessionManager、记住我RememberMeManager

3.Realm --shiro连接数据库的桥梁。
	用于认证和授权
	注入加密类HashedCredentialsMatcher、缓存管理器CacheManager



表单过滤器(FormAuthenticationFilter)


权限注解：
	--开启springAOP注解：配置DefaultAdvisorAutoProxyCreator和AuthorizationAttributeSourceAdvisor两个bean即可
	@RequiresAuthentication	--表示当前Subject已经通过login进行身份验证，即Subject.isAuthenticated()返回true
	@RequiresUser			--表示当权Subject已经身份验证或通过记住我登录
	@RequiresRoles("role1")	--表示需要role1角色
	@RequiresRoles(value = {"role1", "role2"}, logical = Logical.OR)	--表示需要role1或role2角色
	@RequiresPermissions("/permission1")	--表示需要permission1权限
	@RequiresPermissions(value = {"permission1", "permission2"}, logical = Logical.OR)	--表示需要permission1或permission2权限


统一异常处理：
	针对普通请求和ajax异步请求的异常进行处理


1.认证、授权、realm
Shiro认证流程：
	创建SecurityManager -> 将SecurityManager注入SecurityUtils中 -> 创建主体Subject -> 主体提交认证请求 -> SecurityManager认证 -> Authentication认证 -> Realm验证	
Shiro授权流程：
	创建SecurityManager -> 将SecurityManager注入SecurityUtils中 -> 创建主体Subject -> 主体授权 -> SecurityManager授权 -> Authorizer授权 -> Realm获取角色权限数据

简单认证和授权测试：
-1）导入jar包
	<dependency>
		<groupId>org.apache.shiro</groupId>
		<artifactId>shiro-core</artifactId>
		<version>1.4.0</version>
	</dependency>
	<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>RELEASE</version>
	</dependency>
-2）测试
public class SimpleRealmTest {
	
	SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm();
	
	@Before
    public void addUser() { //模拟数据
        simpleAccountRealm.addAccount("admin", "123456", "admin", "user");
    }
	
	@Test
	public void test1() {
		// 1.创建SecurityManager
		DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
		defaultSecurityManager.setRealm(simpleAccountRealm);
		
		// 2.主体提交认证请求
		SecurityUtils.setSecurityManager(defaultSecurityManager);
		Subject subject = SecurityUtils.getSubject();
		
		UsernamePasswordToken token = new UsernamePasswordToken("admin", "123456");
		subject.login(token);
		
		System.out.println("是否登录:" + subject.isAuthenticated());
		
		subject.checkRole("admin"); //有admin角色
		subject.checkRoles("admin", "user"); //同时有admin和user角色
		
		subject.logout(); //登出
		System.out.println("是否登录:" + subject.isAuthenticated());
	}
}


加密(HashedCredentialsMatcher)
	流程：创建HashedCredentialsMatcher对象，并设置散列算法和计算次数 -> 将HashedCredentialsMatcher对象设置到我们的Realm中
测试：
	@Before
	public void addUser() {
		// System.out.println(new Md5Hash("admin", "admin", 1023).toString()); //加密(密码，盐值，循环次数)
		
		simpleAccountRealm.addAccount("admin", "e10adc3949ba59abbe56e057f20f883e", "admin", "user");

		// 创建HashedCredentialsMatcher并设置到realm中
		HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
		matcher.setHashAlgorithmName("md5");
		matcher.setHashIterations(1);
		simpleAccountRealm.setCredentialsMatcher(matcher);
	}


2.Realm
	有SimpleAccountRealm、IniRealm、JdbcRealm和自定义Realm等。

自定义Realm（重要）！！！
	--继承AuthorizingRealm，重写认证(doGetAuthenticationInfo)和授权(doGetAuthorizationInfo)方法。
测试：
-1）创建实体
public class User {
	private String username;
	private String password;
	...
}

-2）创建自定义Realm
public class UserRealm extends AuthorizingRealm {
	
	// 模拟数据库或缓存的数据
	Map<String, User> userMap = new HashMap<String, User>(16);
	Set<String> roleSet = new HashSet<>();
	Set<String> permissionSet = new HashSet<>();
	{
		userMap.put("admin", new User("admin", new Md5Hash("123456", "admin").toString())); 
		roleSet.add("admin"); roleSet.add("user");
		permissionSet.add("user:select"); permissionSet.add("user:update");
	}

	/**
	 * 授权
	 */
	@Override
	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
		SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
		
		// 模拟数据：从数据库或者缓存中，通过username获取角色及权限数据
//		String username = (String) principals.getPrimaryPrincipal();
//		Set<Role> roleSet = findRolesByUsername(username);
		simpleAuthorizationInfo.setRoles(roleSet);
		simpleAuthorizationInfo.setStringPermissions(permissionSet);
		
		return simpleAuthorizationInfo;
	}

	/**
	 * 认证
	 */
	@Override
	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
		// 1.从主体传过来的认证信息（用户名、凭证/密码）
		String username = (String) token.getPrincipal();
		
		// 2.模拟数据：通过username获取User记录，仅需要password和salt
		User user = userMap.get(username);
		
		SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(username, user.getPassword(), getName());
		simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(username));
		return simpleAuthenticationInfo;
	}
}
-3）测试
public class UserRealmTest {

	@Test
	public void testUserRealm() {
		// 1.创建Realm对象
		UserRealm userRealm = new UserRealm();

		// 1.1 创建HashedCredentialsMatcher
		HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
		matcher.setHashAlgorithmName("md5");
		matcher.setHashIterations(1);
		userRealm.setCredentialsMatcher(matcher);

		// 2.创建SecurityManager，将Realm对象注入
		DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
		defaultSecurityManager.setRealm(userRealm);

		// 3.主体提交认证请求
		SecurityUtils.setSecurityManager(defaultSecurityManager);
		Subject subject = SecurityUtils.getSubject();
		UsernamePasswordToken token = new UsernamePasswordToken("admin", "123456");
		subject.login(token);

		System.out.println("是否登录:" + subject.isAuthenticated());

		// 4.检查用户角色、权限
		subject.checkRoles("admin"); // 授权
		subject.checkPermission("user:select");

		subject.logout();
		System.out.println("是否登录:" + subject.isAuthenticated());
	}
}


设置缓存(CacheManager)
	--用于Realm的doGetAuthorizationInfo()方法中，将角色和权限数据缓存起来。不然每次使用shiro:hasRole、shiro:hasPermission等标签，都会调用一次doGetAuthorizationInfo（）方法
	流程：创建Cache的bean对象 -> 将该对象set到realm或securityManager中


记住我(RememberMe)
	通过login()认证登录的，即authentication==true，其访问权限最高，能访问所有页面；登录时勾选了“记住我”，rememberMe==true，则可以访问所有user控制的页面，但不能访问authc控制的页面。
	流程：创建记住我管理器(CookieRememberMeManager)的bean对象 -> 将该对象set到realm或securityManager中




过滤器规则：
	user --只要有用户(subject.isRemembered()==true or subject.isAuthenticated()==true)即可访问成功
	authc --会判断用户是否已登录(isAuthenticated()==true)，是则放行，否则跳转到登录页面。如访问我的订单、提交订单页面，一般使用authc过滤器
因此一般过滤器设置如下：
	Map<String, String> filterChainDefinitionMap = new LinkedHashMap<String, String>();
	filterChainDefinitionMap.put("/assets/**", "anon"); //静态资源文件css、img、js
	filterChainDefinitionMap.put("/login", "anon");
	filterChainDefinitionMap.put("/logout", "logout");
	filterChainDefinitionMap.put("/**", "user"); //user表示authentication=true || rememberMe=true 均可访问
	filterChainDefinitionMap.put("/pay/**", "authc"); //支付页面需要已登录